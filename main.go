// Package bpf-elf2insn provides a utility that extracts Linux kernel
// eBPF instructions from an ELF file (generated by LLVM) and prints
// C-like output. This can be used to populate a struct bpf_insn
// instance which can then be used to attach the eBPF program to any
// supported hook such as a socket, syscall, tracepoint or kprobe.
//
// Installation
//
//     go get -u github.com/anmolsarma/bpf-elf2insn
//
// Usage
//
//     bpf-elf2insn elf.o section
package main

import (
	"debug/elf"
	"encoding/binary"
	"fmt"
	"os"
)

type bpfInstruction struct {
	OpCode    uint8
	Regs      uint8
	Offset    uint16
	Immediate uint32
}

const (
	ld    uint8 = 0x00
	ldx   uint8 = 0x01
	st    uint8 = 0x02
	stx   uint8 = 0x03
	alu   uint8 = 0x04
	jmp   uint8 = 0x05
	alu64 uint8 = 0x07

	ja   uint8 = 0x00
	call uint8 = 0x80
	exit uint8 = 0x90

	bpfX uint8 = 0x08
)

var bpfInsClasses = map[uint8]string{
	0x00: "BPF_LD",
	0x01: "BPF_LDX",
	0x02: "BPF_ST",
	0x03: "BPF_STX",
	0x04: "BPF_ALU",
	0x05: "BPF_JMP",
	0x06: "BPF_RET",
	0x07: "BPF_ALU64",
}

var bpfSizes = map[uint8]string{
	0x00: "BPF_W",
	0x08: "BPF_H",
	0x10: "BPF_B",
	0x18: "BPF_DW",
}
var bpfModes = map[uint8]string{
	0x00: "BPF_IMM",
	0x20: "BPF_ABS",
	0x40: "BPF_IND",
	0x60: "BPF_MEM",
	0x80: "BPF_LEN",
	0xa0: "BPF_MSH",
}

var bpfAluOps = map[uint8]string{
	0x00: "BPF_ADD",
	0x10: "BPF_SUB",
	0x20: "BPF_MUL",
	0x30: "BPF_DIV",
	0x40: "BPF_OR",
	0x50: "BPF_AND",
	0x60: "BPF_LSH",
	0x70: "BPF_RSH",
	0x80: "BPF_NEG",
	0x90: "BPF_MOD",
	0xa0: "BPF_XOR",
	0xb0: "BPF_MOV",
	0xc0: "BPF_ARSH",
}

var bpfJmpOps = map[uint8]string{
	0x00: "BPF_JA",
	0x10: "BPF_JEQ",
	0x20: "BPF_JGT",
	0x30: "BPF_JGE",
	0x40: "BPF_JSET",
	0x50: "BPF_JNE",
	0xa0: "BPF_JLT",
	0xb0: "BPF_JLE",
	0x60: "BPF_JSGT",
	0x70: "BPF_JSGE",
	0xc0: "BPF_JSLT",
	0xd0: "BPF_JSLE",
	0x80: "BPF_CALL",
	0x90: "BPF_EXIT",
}

func parseInstruction(opCode uint8, registers uint8, offset uint16, immediate uint32) string {
	insClass := opCode & 0x07
	switch insClass {
	case ld, ldx, st, stx:
		size := bpfSizes[(opCode & 0x18)]
		mode := bpfModes[(opCode & 0xe0)]
		dstReg := "0"
		srcReg := "0"
		if insClass == ldx {
			dstReg = fmt.Sprintf("BPF_REG_%d", (registers & 0xF))
		} else if insClass == stx {
			srcReg = fmt.Sprintf("BPF_REG_%d", ((registers >> 4) & 0xF))
		}

		return fmt.Sprintf("%s | %s | %s, %s, %s, %d, %d", bpfInsClasses[insClass], size, mode, dstReg, srcReg,
			offset, immediate)

	case alu, alu64:
		src := opCode & 0x08
		dstReg := fmt.Sprintf("BPF_REG_%d", (registers & 0xF))
		srcReg := "0"
		srcStr := "BPF_K"
		if src == bpfX {
			srcReg = fmt.Sprintf("BPF_REG_%d", ((registers >> 4) & 0xF))
			srcStr = "BPF_X"
		}
		op := bpfAluOps[(opCode & 0xF0)]
		return fmt.Sprintf("%s | %s | %s, %s, %s, %d, %d", bpfInsClasses[insClass], srcStr, op, dstReg, srcReg, offset, immediate)
	case jmp:
		src := opCode & 0x08
		op := opCode & 0xF0
		dstReg := "0"
		if !(op == ja || op == call || op == exit) {
			dstReg = fmt.Sprintf("BPF_REG_%d", (registers & 0xF))
		}
		srcReg := "0"
		srcStr := "BPF_K"
		if src == bpfX {
			srcReg = fmt.Sprintf("BPF_REG_%d", ((registers >> 4) & 0xF))
			srcStr = "BPF_X"
		}
		return fmt.Sprintf("%s | %s | %s, %s, %s, %d, %d", bpfInsClasses[insClass], srcStr, bpfJmpOps[op], dstReg, srcReg, offset, immediate)
	default:
		dsrReg := (registers & 0xF)
		srcReg := ((registers >> 4) & 0xF)
		return fmt.Sprintf("%d, %d, %d, %d, %d", opCode, dsrReg, srcReg, offset, immediate)
	}
}

func main() {
	if len(os.Args) != 3 {
		fmt.Printf("Error: invalid arguments\n\nUsage: %s elf.o section\n", os.Args[0])
		os.Exit(-1)
	}

	file, err := elf.Open(os.Args[1])
	if err != nil {
		fmt.Printf("Error parsing file %s\n%s\n", os.Args[1], err)
		os.Exit(-1)
	}
	defer file.Close()

	section := file.Section("classifier")
	if section == nil {
		fmt.Printf("Error: No section named '%s' in file %s\n", os.Args[2], os.Args[1])
	}

	var ins bpfInstruction
	insSeeker := section.Open()
	for {
		err := binary.Read(insSeeker, binary.LittleEndian, &ins)
		if err != nil {
			break
		}
		fmt.Printf("{%s},\n", parseInstruction(ins.OpCode, ins.Regs, ins.Offset, ins.Immediate))
	}
}
